test_that("my_e2trunct matches simulations", {
  x = rt(1000000,df=4)
  expect_equal(mean(x[abs(x)<1]^2),my_e2trunct(-1,1,4),tolerance=0.01)
})

test_that("my_e2truncnorm matches simulations", {
  x = rnorm(1000000)
  expect_equal(mean(x[abs(x)<1]^2),my_e2truncnorm(-1,1),tolerance=0.01)
})

test_that("my_etrunct matches simulations", {
  x = rt(1000000,df=4)
  expect_equal(mean(x[x>0 & x<2]),my_etrunct(0,2,4),tolerance=0.01)
  expect_equal(mean(x[x>1 & x<5]),my_etrunct(1,5,4),tolerance=0.01)
})

test_that("comp_postmean2 is 0 for null", {
    skip("no compost yet")
    set.seed(1)
    z=rnorm(10)
    expect_equal(comp_postmean2(unimix(1,0,0),z,rep(1,10),v=NULL),matrix(0,10,nrow=1))
    expect_equal(comp_postmean2(unimix(1,0,0),z,rep(1,10),v=4), matrix(0,10,nrow=1))
    expect_equal(comp_postmean2(normalmix(1,0,0),z,rep(1,10),v=NULL),matrix(0,10,nrow=1))
    z.ash = ash(z,1,df=4,g=unimix(1,0,0),fixg=TRUE)
    expect_equal(z.ash$PosteriorSD,rep(0,10))
    expect_equal(z.ash$PosteriorMean,rep(0,10))
})

test_that("comp_postmean2.unimix matches simulations", {
  bhat = 3
  s = 2
  x = bhat+s*rt(100000,df=3)
  m = c(mean(x[x<2 & x>0]),mean(x[x<2 & x>1]),mean(x[x<0 & x>(-2)]))
  m2 = cbind(mean(x[x<2 & x>0]^2),mean(x[x<2 & x>1]^2),mean(x[x<0 & x>(-2)]^2))
  g= unimix(c(0.5,0.2,0.3),c(0,1,-2),c(2,2,0))
  temp2=as.vector(comp_postmean2(g,c(3),c(2),3))
  temp = as.vector(comp_postmean(g,3,2,3))
  expect_equal(mean((temp2-m2)^2), 0,tolerance=0.01)
  expect_equal(mean((temp-m)^2), 0,tolerance=0.01)
})

test_that("posterior means and sds computed for unimix from very flat prior are correct", {
  set.seed(1); z = rnorm(10,0,2); s=rgamma(10,10,10)
  #fit under t likelihood
  z.ash=ash.workhorse(betahat = z,sebetahat = s,df=5,g=unimix(c(0.5,0.5),c(-100,-20),c(100,20)),fixg=TRUE, likelihood = "t")
  expect_equal(z.ash$PosteriorSD,s*sd(rt(1000000,df=5)),tolerance=0.01)
  #now do normal version
  z.ash=ash.workhorse(betahat = z,sebetahat = s,df=NULL,g=unimix(c(0.5,0.5),c(-100,-20),c(100,20)),fixg=TRUE)
  expect_equal(z.ash$PosteriorSD,s,tolerance=0.01)
})

test_that("posterior means and sds computed for unimix from NAs match prior mean and sd", {
    skip("missing data not implemented yet")
  set.seed(1); z = c(NA,rnorm(10,0,2)); s=c(rgamma(10,10,10),NA)
  z.ash=ash.workhorse(betahat = z, sebetahat = s,df=5,g=unimix(c(0.5,0.5),c(-100,-20),c(100,20)),fixg=TRUE, likelihood = "t")
  priorsd = sd(c(runif(1000000,-100,100),runif(1000000,-20,20)))
  expect_equal(z.ash$PosteriorMean[1],0)
  expect_equal(z.ash$PosteriorMean[11],0)
  expect_equal(z.ash$PosteriorSD[1],priorsd,tolerance=0.01)
  expect_equal(z.ash$PosteriorSD[11],priorsd,tolerance=0.01)
})
